# Задание
Надо написать `iproto`-сервер, который будет осуществлять операции над некоторым стораджем.

При написании можно использовать языки `C` и `Go`. Сервер должен работать под ОС Linux.
Помимо стандартной библиотеки языка можно (но не обязательно) использовать следующие библиотеки:
C                                    | Go
------------------------------------ | --------------------------------------------
pthread                              | https://github.com/vmihailenco/msgpack
https://github.com/enki/libev        | https://github.com/prometheus/client_golang/
https://github.com/tarantool/small   |
https://github.com/tarantool/msgpuck |

**/!\\ Важно /!\\**

При разработке исходим из того, что сервер будет эксплуатироваться под высокой нагрузкой.
Клиенты сервера потенциально могут нарушать соглашения, описанные ниже.
Сервер должен корректно обрабатывать такие случаи и не терять работоспособности.

## Протокол
`iproto` - это бинарный протокол, работающий поверх TCP соединения.
Протокол позволяет делать простые вызовы RPC API с минимальными издержками на сериализацию/десериализацию данных.
Схема протокола:
```
<packet> ::= <request> | <response>
<request> ::= <header><body>
<response> ::= <header><return_code><body>
<header> ::= <func_id><body_length><request_id>
<func_id> ::= <uint32> - идентификатор вызываемой функции (см. раздел API)
<body_length> ::= <uint32> - длина тела запроса
<request_id> ::= <uint32> - идентификатор запроса, возвращается в ответе, нужен для асинхронной работы с сервером
<return_code> ::= <uint32> - код ответа (см. раздел API)
<body> ::= <byte>... - закодированная в MsgPack (см. раздел API) последовательность байт длиной <body_length>
```

## Сторадж
Статический массив строк длиной `1000 элементов`. Каждая строка не более `256 байт`.

Сторадж может находится в следующих состояних:
- `READ_ONLY` - доступен только на чтение
- `READ_WRITE` - доступен на чтение и запись
- `MAINTENANCE` - сторадж недоступен

## API
`return_code`:
- `0` - успех, в этом случае клиент ожидает получить в `body` результат, описанный в таблице ниже
- `!= 0` - ошибка, в этом случае клиент ожидает получить в `body` msgpack-encoded строку - текстовое описание ошибки.
Спецификация кодов ошибок остаётся на усмотрение разработчика сервера.

Тела запросов и ответов закодированы в формате MsgPack. Спецификация формата:
https://github.com/msgpack/msgpack/blob/master/spec.md

`func_id`    | Имя обработчика                  | Схема тела запроса | Схема тела ответа | Описание
------------ | -------------------------------- | ------------------ | ----------------- | --------
`0x00010001` | `ADM_STORAGE_SWITCH_READONLY`    | `<nil>`            | `<nil>`           | переводит сторадж в состояние `READ_ONLY`
`0x00010002` | `ADM_STORAGE_SWITCH_READWRITE`   | `<nil>`            | `<nil>`           | переводит сторадж в состояние `READ_WRITE`
`0x00010003` | `ADM_STORAGE_SWITCH_MAINTENANCE` | `<nil>`            | `<nil>`           | переводит сторадж в состояние `MAINTENANCE`
`0x00020001` | `STORAGE_REPLACE`                | `<int><string>`    | `<nil>`           | записывает в сторадж строку по индексу
`0x00020002` | `STORAGE_READ`                   | `<int>`            | `<string>`        | возвращает строку из стораджа по индексу

## Соглашение об использовании ресурсов
- CPU <= 4 ядер
- RPS (Requests Per Second) <= 100 на одного клиента
- Кол-во параллельных соединений <= 100

## Формат сдачи работы
Задание принимается в виде репозитория на GitHub

## Дополнительные задания
При желании можно выполнить одно или несколько дополнительных заданий из списка, будет плюсом при оценке работы:
- Выложить серию git-коммитов. В случае, если в вашей истории коммитов будут оформлены понятные сообщения и
каждый коммит будет показывать понятный атомарный инкремент к кодовой базе - это, определённо, будет плюсом при оценке работы.
- Написать документацию
- Настроить CI
- Настроить сборку и запуск сервера в Docker-контейнере
- Покрыть код тестами
- Распараллелить выполнение вычислений на сервере так, чтобы полностью утилизировать кол-во ядер CPU
в соответствии с соглашением выше
- Измерить производительность и оптимизировать тонкие места
- Реализовать кодогенерацию для обработчиков
- Настроить рейт-лимиты
- Покрыть код логами и метриками, построить дашборд в Grafana
- Настроить вендоринг зависимостей (если они есть)
- Научиться поднимать несколько копий сервера и придумать механизм балансировки нагрузки
- Обеспечить graceful shutdown/graceful restart сервера. Написать systemd-unit